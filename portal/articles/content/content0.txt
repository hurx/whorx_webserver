测试的形而上学
--术业--
2015-06-17
		<p>尽早发现问题，并解决问题。——题记</p>
		<p>1983年IEEE对软件测试进行了准确的定义：软件测试是使用人工或自动手段来运行或测定某个系统的过程，检验它是否满足规定的需求或是弄清楚预期结果与实际结果之间的差距。</p>
		<p>关于题记的补充，解决问题时，并非所有的软件缺陷都要修复。可能原因有：
		<p>1.没有足够时间；</p>
		<p>2.不算真正的软件缺陷；</p>
		<p>3.修复的风险太大；</p>
		<p>4.不值得修复；</p>
		<p>等等。</p>
		<p>本文并不是普及测试常识，重点是<span class="bigger">形而上学（玄学！）</span>。以下重点阐述如何发现问题。</p>
		<p>首先得申明三点：</p>
		<p>1.尚未发现或观察到的软件缺陷只能说是潜在缺陷；</p>
		<p>2.“经验是每个人为其错误寻找的代名词”--Oscar Wilder。软件测试是非常需要经验的，但是经验恰恰也是双刃剑，常常会使你陷入沼泽地。</p>
		<p>3.<span class="bigger">没有银弹</span>，零缺陷是相对的，缺陷存在是绝对的，没有任何方法能保证零缺陷。</p>
		<p>0.<span class="bigger">知识、经验的作用是辅助思考，而不是禁锢思想</span>。切记本末倒置。</p>
		<p>其次，明确工作范围。因为专业的测试人员是很“软件工程的”，做好且只做分内工作对软件工程来说是很重要的。“软件测试人员的任务不是定义软件要符合何种标准和规范，这是项目经理或者编写产品说明书的人的任务。软件测试人员要做的是观察，“检查”采用的标准是否正确、有无遗漏。在对软件进行确认和验收时，还要注意是否与标准和规范相抵触，把标准和规范视为产品说明书的一部分。”——《构建之法》</p>
		<p>平时常提到的<span class="bigger">黑/白盒测试，只是测试设计方法，并非测试方法</span>。具体分类如下：静态黑盒测试（eg：说明文档）、动态黑盒测试、静态白盒测试（eg：检视代码）、动态白盒测试。简单的理解就是，静态，不运行软件；动态，运行软件；黑盒，看不到（代码）实现细节；白盒，看到源代码逻辑。特别提出静态黑盒测试，提供给用户的软/硬件、文档材料等，都需要测试。这里的用户，指的是所有可能使用产品的人，例如测试人员、一线交付人员。所以，帮助文档、用户手册等，都需要测试。</p>
		<p>以下的流程作为经验总结：怎么发现问题&解决问题。</p>
		<p>1.需求分析</p>
		<p>需求分析的对象，不应只局限于规格文档，还有实际使用场景。需求分析的目的，是一方面搞清楚软件到底做了什么，另一方面也要找到用户的painpoint。甚至是否能解决用户的painpoint。需求分析过程中，弄清楚用户是谁，哪些用户。不同的用户，用法不同，测试点也就不同。</p>
		<p>在不同的软件工程方法之下，需求的定义是不同的。例如：瀑布模型中，需求是不可变的；而敏捷模型中，需求是随时可变的。这也是测试需要关注的。</p>
		<p>2.硬件分析（哪些硬件&接口）</p>
		<p>笼统的概括产品结构：硬件-->驱动-->内核接口-->应用，其中驱动和内核通常是由操作系统决定的（若是开源系统也可以人为更改），而可控的只有硬件选择和应用程序（即软件本身）。不同的硬件，不同的操作系统同样对应不同的测试点和不同的测试标准。</p>
		<p>硬件分析，主要是看硬件是否能提供软件所需要的资源，以及这些资源的占用情况。</p>
		<p>3.软件分析（业务流程分析） </p>
		<p>软件分析的目的是把软件拆成灰盒甚至白盒来看，查看每个需要关注的点。并不是做单元测试，单元测试的目的是找到每个点有没有问题。软件分析的目的是找出整个软件的关键点&可能出现问题的点。</p>
		<p>关于测试驱动开发，这个就好比盖房子，另一种情况是先砌砖再量是否与地面垂直。而TDD则是先用一条垂直的线定好位，再砌砖。</p>
		<p>4.压力传递=>瓶颈分析=>风险评估</p>
		<p>有了以上的工作之后，分析软/硬件的压力传递可以得出软/硬件的瓶颈在哪里，再通过瓶颈分析，可以得出风险在什么地方。找到了风险，自然就知道哪些是测试点。在绝对的逻辑中，甚至可以说哪些地方不需要测试关注。</p>
		<p>5.评价标准（关键指标KPI，用户体验的量化）</p>
		<p>评价标准怎么来？首先是行业规范，其次是经验总结。经验总结主要来源于，a）测试的结果；b）实际使用情况下统计的数据。</p>
		<p>至于如何量化一些产品的关键指标，甚至是量化用户体验，需要用到建模的方式。</p>
		<p>6.测试策略=需求（R1,R2，...）*用户(C1,C2,...)*硬件(H1,H2,...)*软件(P1,P2,...)*其他因素（O1,O2,...） （几何乘积，括号中为影响因子）</p>
		<p>特别说明：以上6点分析的结果，只对功能测试、集成测试、性能测试有用，其他如安全测试等不适用</p>
		<p>7.测试计划</p>
		<p>人力/物料预估（参见《人月传说》）；</p>
		<p>测试用例，请结合前人&自己经验总结的特殊测试场景，以及尽可能详细。因为这个是回归问题时复制“案发现场”的重要资料。</p>
		<p>测试执行，一个很枯燥但是又不得不很认真对待的过程。</p>
		<p>8.过程记录/数据采集（如何采集+采集哪些数据）与分析（结合评价标准）</p>
		<p>任何科学严谨的工作，都应该有一个完整的记录。测试过程，更少不了这种记录，不但可以用做以后的参考，也可能用于修正之前有误的地方。这个记录也是尽可能详细。数据搜集/现象归纳尽可能完整。否则就是为了各种数据/结果的无休止的重复工作。</p>
		<p>数据分析，如何算达标、如何算没问题等等，除了上面评价标准，更需要一个严谨的评价体系。这个体系不一定是由测试人员定的，但测试人员一定要有一把尺。结论的精确度和准确度，全看这把尺。</p>
		<p>9.测试报告</p>
		<p>写东西，就是在做一件产品。用户是谁，他希望看到什么，得到什么。</p>
		<p>这种东西，切记不要为了骗别人而骗自己。</p>
		<p>10.问题闭环</p>
		<p>务必保证问题以足够好的方式解决，否则以上9条的工作都打了水漂。</p>
		<p>后记：</p>
		<p>此文，一则总结；二则警醒自己；三则感谢那个给我成长的团队。</p>